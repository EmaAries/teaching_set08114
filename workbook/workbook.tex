\documentclass[12pt, a4paper, twoside]{book}

\usepackage{helvet}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage[
	a4paper,
	outer=2cm,
	inner=4cm,
	top=2cm,
	bottom=2cm
]{geometry}
\usepackage{float}
\usepackage{tabularx}
\usepackage[disable]{todonotes}
\usepackage{color, soul}
\usepackage{amsmath}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{framed}
\usepackage{subcaption}
\usepackage{titlepic}
\usepackage{fancyhdr}
\usepackage[simplified]{styles/pgf-umlcd}
\usepackage{shorttoc}
\usepackage{url}
\usepackage{paralist}
\usepackage{dirtytalk}
\usepackage{verbatim}

\definecolor{grey}{rgb}{0.9, 0.9, 0.9}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0.0}

\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\scriptsize\color{white}\ttfamily,
    stringstyle=\color{white},
    keywords={}
}

\lstdefinestyle{makefile}
{
    numberblanklines=false,
    language=make,
    tabsize=4,
    keywordstyle=\color{red},
    identifierstyle= %plain identifiers for make
}

\lstset{
  language=Python,                % the language of the code
  escapeinside={\%*}{*)},
  basicstyle=\footnotesize\ttfamily,
  numbers=left,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{dkred},         % string literal style
  columns=fixed,
  extendedchars=true,
  frame=single,
}

%\renewcommand{\chaptername}{Topic}

% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO, LE]{\small \rightmark}
\fancyfoot[RO, LE]{\small \thepage}

\newcommand{\blank}[1]{\hspace*{#1}}

\begin{document}

\frontmatter

\begin{titlepage}
\vspace*{5cm}
\begin{center}
\includegraphics[width=.5\textwidth]{images/EdNapUniLogoCMYK}~\\[1cm]

\textsc{\Large Edinburgh Napier University}\\[1.5cm]

\textsc{\LARGE \bfseries SET08114 Mobile Application Development}\\[0.5cm]

\hrulefill \\[0.4cm]
{\huge \bfseries Notes \& Workbook 2015-2016 \\[0.4cm] }
\hrulefill \\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\textbf{Dr Simon Wells} \\
\end{flushleft}
\end{minipage}

\vfill

\end{center}
\end{titlepage}

\shorttoc{Overview}{0}

\setcounter{tocdepth}{2}
\cleardoublepage
\tableofcontents
\listoffigures
%\listofalgorithms
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\mainmatter
%\part{Admin}


\part{Labs \& Practical Work}

\chapter{Getting Started}
\label{lab1}
\paragraph{} With the practical portion of this module we aim to learn about the functionality offered by the Android platform. We will treat each functionality as a building block which can be combined with other blocks, and glued together using the Java language to build our own apps. Throughout the practical labs we will explore these blocks and begin to combine them in simple ways. In your coursework assignment you will then have the opportunity to use these skills to design and implement an app of your own.

\section{Aims}
\paragraph{} At the end of the practical portion of this topic you will be able to:

\begin{itemize}
\item Install the android development tools (OPTIONAL: Only if you have your own machine)
\item Create a default `Hello Android' application
\item Create an AVD for running your application
\end{itemize}

\paragraph{} We will use Android Studio to develop mobile applications on this module. Android Studio is an Integrated Development Environment (IDE) for managing the writing, testing, and running of Android applications. IDEs like Android Studio have many advantages when starting out with Android development. A lot of early activities when learning about Android is related to finding out what the platform offers. With an IDE there is usually a window or some code-completion that makes suggestions so that, over time, you become more familiar with the options available to you. There are particular advantages to using the command-line which are important, for example, when large teams of developers are working within a professional environment to collaboratively build applications. However, in this module we will concentrate on using an IDE.

\paragraph{IMPORTANT} \emph{This introductory practical is the only one which will describe in detail the process of creating a new project. All subsequent labs will assume that you can achieve this for yourselves. If in doubt refer back to this practical. It will be your responsibilty to explore and become familiar with your development environment so that you can at least perform basic tasks.}

\section{Say ``Hello Android''}
\label{hello}
\paragraph{} With an IDE there is a lot of initial hand-holding available to help get you started. In fact, to run a ``Hello World'' or more appropriately ``Hello Android'' app requires no code to be written at all. The entire app is generated ready to be compiled, installed, and run on an appropriate Android device such as connected hardware, emulator, or a virtual device. This is very useful because, depending upon the options that you select when you create a new app project, the basic scaffold for your app is automatically generated for you and is \emph{ready to run}, i.e. if you don't break it then Android Studio gives you a fresh, ready to run app (that does nothing very much). 

\paragraph{} This worksheet aims to give a pictorial introduction to the process of creating a first ``Hello Android'' application using Android Studio as your IDE. Studio actually does nearly all of the work for you and most of the time, at this stage in the module, all you need to do is {\bf{accept the defaults}}. So let's start by launching Android Studio.

\paragraph{} Use the `Quick Start' options in the right-hand pane and click `Start a new Android Studio project' as shown in Figure \ref{fig:android.studio_welcome}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_01_welcome}
\caption{Android Studio welcome pane}
\label{fig:android.studio_welcome}
\end{figure}

\paragraph{} You should see the window shown in Figure \ref{fig:android.studio_config}. Enter a name for your new Application. This will also be used for your project name. For our first app let's call it `HelloNapier'. For `Company Domain' I suggest you enter `napier.ac.uk'. Now click Next to continue.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_02_configure}
\caption{Android Studio new app configuration pane}
\label{fig:android.studio_config}
\end{figure}

\paragraph{} On this screen, accept the defaults for now. NB. These should be as shown in Figure \ref{fig:android.studio_form}. Now click Next.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_03_form-factors}
\caption{Android Studio form factor selection pane}
\label{fig:android.studio_form}
\end{figure}

\paragraph{} Again, accept the default, `Blank Activity', which should be highlighted, then click Next.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_06_activity}
\caption{Android Studio activity setting pane}
\label{fig:android.studio_activity}
\end{figure}

\paragraph{} Accept the defaults on this screen for now and click Next again.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_07_options}
\caption{Android Studio options pane}
\label{fig:android.studio_options}
\end{figure}

\paragraph{} After a brief pause, whilst your machine loads all of the relevant libraries and creates your project file, you should be presented with the Android Studio workspace as shown in Figure \ref{fig:android.studio_studioui}.

\paragraph{NB.} It can take a while for your new project to load completely which depends upon the speed of your machine. If there are any errors or warnings on screen, especially in the preview window which renders waht your Android app interface will look like, then your project hasn't loaded completely yet.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_08_studio-ui}
\caption{Android studio UI with default Android app}
\label{fig:android.studio_studioui}
\end{figure}

\paragraph{} Congratulations. You just created a New Android Studio projectThis process can be summarised as follows:

\begin{enumerate}
\item Click `Start a new Android Studio project'
\item Type in an application name \& Company Domain (napier.ac.uk) then click `Next'
\item Select an API level
\item Ensure `Blank Activity' is selected then click `Next'
\item Click Finish
\end{enumerate}

\paragraph{} Now you have created your first Android project. Whenever we say `Create a new project' we mean go though steps 1 to 5 ({\bf{you will have to either give each new project a different name or else save them to different locations}}).

\paragraph{} It is worth going through this process several times to become familiar with it. Once you have done it half a dozen times or so you should become comfortable with the idea of creating a new Android project and it shouldn't take more than a few seconds.

\paragraph{} It is also worth exploring some of the options that the project creation wizard offers. In particular it is worth exploring the API levels page to see what the differences are between the different API levels supported by Android. When you are on the form factors page shown in Figure \ref{fig:android.studio_form} click the link to ``Help me choose''. This will cause the API Level window to be displayed which is illustrated in Figure \ref{fig:android.studio_apilevel}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_04_api-level}
\caption{Android Studio API level selection screen}
\label{fig:android.studio_apilevel}
\end{figure}


\paragraph{} This page gives you an idea of the proportion of the market for Android devices that you can target with each API level. If you click on a particular level, e.g. `2.3 Gingerbread' then you will see extra information about the features offered by that verson of Android. Remember, higher API levels support newer or more refined features whereas lower levels are supported by a wider proportion of the population of Android devices. Choosing an API level is therefore partly a technical decision, because it affects what you can do, partly a business decision, because it affects the size of your potential customer base, and partly an aesthetic decision, because how things are displayed is also affected by API level. So choose wisely ;) 

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/android-studio_05_api-level-details}
\caption{Android Studio API level details screen}
\label{fig:android.studio_apidetails}
\end{figure}

\paragraph{} It can take quite a while, even minutes, for Android Studio to completely load your new project and all of the supporting libraries. If the preview of the Android UI isn't fully displayed or has a message on it then Android Studio is still loading and compiling things so it is best to let it finish. Similarly if there are errors or warnings in the ``Problems'' tab then it is likely that these are due to your IDE still loading and building resources. Sometime the IDE can also get ahead of itself and tries to use one component before another is properly loaded. Usually when this occurs there will be a message with a link to let you reload or retry the component. When we build a new Android Studio project, especially for the first time, there will be a lot of code to generate and libraries to link, and this can take a while. Also, because everyone in the class is trying to do this at the same time, and Android Studio runs across the university network from the ``U:\'' drive there can be some significant lag. At this point you should just wait for things to resolve themselves. You imght also notice, in the status bar of Android Studio, that there is a message regarding scanning or indexing files, this happens when we first use Android Studio, it can take a while to complete, and it can cause significant performance issues initially.

\paragraph{} Now you need to build and run your app. This is important because we want to actually see our app running and doing something don't we?

\section{Running our app using Android Virtual Devices (AVDs)}
\label{avd}
\paragraph{} Because Android apps are not Windows (or Linux, or MacOS) apps they will not usually run natively on our operation systems (unless you are using Android as your OS but let's ignore that case for now). That means that you cannot just double click on your app and have it run in a window. Android apps rely on the Android OS to provide not just the platform libraries that contain all the code you didn't write but also all of the app management functionality. Android apps are a collection of activities (we will talk about these in class next week) and the OS manages when to display a given activity and when to allow another activity to take precedence. As a result we need a way to run our Android app. There are three alternatives, you can use a hardware device plugged into your computer via USB, or you can emulate the hardware of an Android device. Android devices usually run on an ARM architecure, which is different to most desktop machines, and thus that architecture needs to be emulatedin software, this can be very slow. A third option is to use a virtual device that runs a version of the Android OS that is built for the x86 architecture. This allows us to use real hardware, e.g. CPU cores and RAM, to run the Android OS in the virtual device. We can then load our Android app in this virtual version of Android and have it run with acceptable performance. This approach is known as using an `Android Virtual Device' (AVD) and we interact with AVDs through the AVD manager. We can access this through the Tools $\to$ Android $\to$ AVD Manager menu option. The AVD manager lets you set up multiple AVDs, e.g. targetting different versions of Android or simulating different hardware capabilities. For the moment we should merely use the default AVD and accept the defaults that the AVD manager suggests. Bare in mind that an AVD is quite large, around 650MB each, so you might not want to create too many of them. Currently AVDs are stored in the C: drive of the JKCC machines so each time you use a different machine you will probably have to create a new AVD. This is a known ``feature'' of the JKCC which is being worked on. 

\paragraph{} Once you have created a new Android device then it it needs to be started. As this process is essentially starting up a whole operating systems this can take a few moment. Eventually however you should see a new window that looks a bit like an Android device

\paragraph{} Once you have an AVD created you can select the Run $\to$ Run `app' menu optionand your Android app will be built and tranferred to your AVD. You might have to select the AVD that you want to run the app in from a list of running devices. NB. If you have attached a harware device to your computer using USB then this device should also be listed however there are some caveats; you will need to have the correct drivers installed for your device and this will probably not work in the JKCC with your own device but should be OK on your own laptop.

\paragraph{} That's it for this week. You should get yourself \emph{very} comfortable with these processes and go through them multiple times as every app that you will build during the mdule, and you will build tens if not hundreds of apps, will require you to set up a new project. You should only need a single AVD using the default settings for the majority of the lab exercises. If other settings are required for a particular exercise then this will be flagged as necessary. That said, experiment with Android studio, explore some of the features that it offers, and get as familar as you can with it so that you are ready to do more in subsequent labs.




\chapter{Baby Steps with Android}

\section{Aims}
\paragraph{} At the end of the practical portion of this topic you will be able to:

\begin{itemize}
\item Understand the basic relationship between Android project files
\item Display text using an Android View
\item Display buttons and respond when they are used
\item Display notifications (Toasts) to users
\item Log output from your app and view it using logcat
\end{itemize}

\section{Preliminaries}
\paragraph{} Create a new Android project using the process we followed for HelloAndroid. You should give your project a different name, for example, `HelloString' (because to begin with we shall be manipulating the strings that say Hello ;). It is a good idea to come up with a naming scheme for your Android projects or perhaps to organise them in folders based upon module topic or semester week number so that later in the course you can refer back to earlier code you have developed.

\paragraph{} In Android Studio open the Activity Java file. This should be called `MainActivity.java' and will be located in the 
\begin{framed}
src/uk/ac/napier/napier-id/HelloString/ 
\end{framed}
\paragraph{} folder of your project. 

\paragraph{} There isn’t a lot to see here. Most of what you see is commonly called `boilerplate' and is basically setting up the things that the Android libraries need to provide the framework for an empty project. What you will notice is that the things you see on screen when you run this app are not anywhere to be found in this Java file. This is because all the text, graphics, and layout information is created and stored in separate XML files. These XML files are then referenced from the Java code or other XML files. This means that Android has a very flexible development system which encourages well structured and reusable designs but the drawback is that it is a little complicated to get started with.

\paragraph{} There are a few things to take particular note of in the MainActivity.java file.

\begin{lstlisting}
    public class MainActivity extends Activity {
\end{lstlisting}

\paragraph{} In this line we are creating a class, called MainActivity, which inherits from the Activity parent class. Rather than creating a main method like we do in a Java program we are allowing the Android libraries to provide the main method instead. This is because we are not writing a Java program, we are writing an Android app, and these are different things. When we write an Android app we will be working within the framework of classes and libraries provided by the Android platform and there are certain requirements for an Android app to become an Android app. Because the core of an Android app is the Activity we must use the existing Android classes that provide Activity functionality. There are a number of Activity and other classes that we can inherit functionality from but for the moment we will concentrate on the core Activity class.

\paragraph{} Because we have inherited from the Activity base-class we must implement a number of methods that allow our apps functionality to `hook in' to the framework provided by the Android platform. Importantly right now we override the onCreate method. This is the method that pretty much starts the life-cycle of our app. It is called when our app is created and does a lot of work for us. In this case, with our basic HelloString app all it does is call the parent class onCreate method to ensure that the hierarchy of Activity classes are properly initialised then

\begin{lstlisting}
setContentView(R.layout.activity_main);
\end{lstlisting}

\paragraph{} Let's unpack this a little. The setContentView part is a call to a method related to displaying something on screen. We then have the argument to this method which contains 
\begin{framed}
R.layout.activity\_main
\end{framed}
\paragraph{} What this means is that we are referencing an Android resource. `R' is short for resource, notice that in package explore there is a folder called `res'. This contains all of the information about things that our can display, amongst other things. For our purposes we can consider `R' to refer to these resources. In reality it is slightly more complicated because when we build our app the contents of the res folder are assembled into a more efficient representation and the `R' file is essentially an index to our efficient representation of our resources. Going back to our line of code, without the res folder there is a sub-folder called layout, inside of which is a file called `activity\_main.xml'. This line of code is essentially saying display the layout described in activity\_main.xml, so perhaps we should take a look at that file. Use package explorer to open it.

\paragraph{} There is a lot to take in in this file. For a start. it doesn't look like a Java language source file. That is because it isn't. It is an eXtensible Markup Language (XML) file\footnote{\url{http://en.wikipedia.org/wiki/XML}}. XML is used to describe and specify Android resources. There are a number of things happening in this file. The top part

\begin{lstlisting}<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">
\end{lstlisting}

\paragraph{} basically describes a layout for the things to display on screen. Essentially telling Android to use the `Relative Layout' to organise the things that it draws and to use the parameters that are supplied e.g. layout\_height, paddingRight, paddingTop, and paddingBottom. We will see more about layouts and how to arrange things nicely on screen in the next practical so for now we will just ignore it. The next section is more interesting right now:

\begin{lstlisting}    <TextView android:text="@string/hello_world" android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
\end{lstlisting}

\paragraph{} This is interesting because it is the bit that tells the Android platform to display our "Hello World" message. Again, like the use of `R' in MainActivity.java to provide flexibility we have another bit of indirection. Instead of just having all of the strings that our app uses in the place that they are used, instead we have them all collected in a single location, another resource file, called strings.xml which can be found here

\begin{framed}
res/values/strings.xml
\end{framed}

\paragraph{} {\bf{Why do you think that it might be useful to collect all of the strings together in one place?}}

\paragraph{} Our layout file contains a reference to a specific string, stored in the strings.xml resource file, which we want to be displayed onscreen in this layout. The reference is the `@string/hello\_world'. The reference uses `@string' to indicate that the string resource is in the strings.xml file then the name of the resource `hello\_world' to specify the particular string to display. Use package explorer to find and open the strings.xml file.

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">HelloAndroid</string>
    <string name="hello_world">Hello world!</string>
    <string name="action_settings">Settings</string>

</resources>
\end{lstlisting}

\paragraph{} The string that displays the message is the one called `hello\_world'. The content of the string comes between the $<$string name="..."$>$$<$/string$>$ tags, in this cases ``Hello world!''. If you havn't done so yet. Run the project and look at the output. Then try altering the content of the string to display another message of your own design. From here you can even change the name of your app by altering the content of the `app\_name' string but we can leave that alone for now.

\paragraph{} While we have the emulator running we will try using it a bit more, the advanced features of the emulator and how we can interface with it will be covered in a later practical but you should make yourself familiar with what the various buttons on the emulator can do:
•	the home button will return you to the home screen, 
•	the menu button differs with each application and 
•	the back button acts like a browser back button. You will find that the emulator contains the majority of a basic Android phones features, exceptions include Bluetooth and camera as they would require specific hardware.
It is possible to run applications already on the emulator, including our application from earlier. Click the launcher grid button (in the centre of the home screen) and scroll through the list of existing apps, you should be able to find your app and run it from here. To add an app to the home page, press and hold the icon and when the emulator changes to the home page you can drag the icon into place and release it to place it there.

\begin{figure}[H]%[htb]
\centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/android_home}
        \caption{Android Home}
        \label{fig:android-home}
    \end{subfigure}
    ~ 
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/android_apps}
        \caption{Android Apps}
        \label{fig:android-apps}
    \end{subfigure}
\caption{Android home screen \& apps}
\label{fig:android-home-apps}
\end{figure}

\section{The DateTime App}
\paragraph{}Now we have an understanding of how the applications are built and executed on the emulator we will build our first application that does something more than just display the Hello message. Along the way we will explore some of the basic user interface controls available on the Android platform. On Android anything that can be displayed on screen is called a View and this includes all of those elements that we are used to on other platforms that we usually refer to as GUI widgets.

\paragraph{} We're going to create an app which displays the current date and time when you click a button. Create a new app and call it `DateTime'. Open the graphical layout - one way of doing this is simply to double click the activity\_main.xml file in the res/layout folder. You can delete the HelloWorld message, just select it with the mouse and delete it, as we won't be using it.

Your should see an area of the Android Studio UI which provides a `Palette' or `toolbox' of graphical widgets that you can use in your app. Drag a textview view from the palette onto the AndroidApp activity layout. Notice that the graphical layout is a good way to place and arrange Android views on screen to rapidly create a GUI. Select the new Text View – then change the Text property to ``DateTime'' (without the quotes) and the name to ``TextView1''. Click now on the activity\_main.xml tab to see what has happened to the XML code – you should now have a block called <EditText...> like so

\begin{lstlisting}
<TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="DateTime"
        android:id="@+id/textView1"
        android:layout_below="@+id/button1"
        android:layout_centerHorizontal="true" />
\end{lstlisting}

\paragraph{} Now return to graphical layout and select Form Widgets. Drag a button over to your activity layout.  Right click (or double click in Android Studio) to edit the text that goes onto the button - and select Edit Text. You can enter the new text in the field at the bottom (under New String...). Change to ``Click me!''. The default name for your button is button1 – check this by clicking on the button then looking at the properties.

\begin{lstlisting}
<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click Me!"
        android:id="@+id/button1"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="79dp"
        android:layout_centerVertical="true" />
\end{lstlisting}

\paragraph{} So we now have a text box and we have a button. Check your app now – select the project from the Package Explorer then click the play button (a green `play' triangle on the menu bar):

\paragraph{} The problem now is that our app doesn't actually do anything. The Click Me! button has no functionality and the TextView will just display DateTime forever. We need to write some code to do something when the button is clicked. We’re going to overwrite the DateTime string with the actual date and time. How are we going to do this? Well, we need to have a handler that will listen for button clicks, we need to write a little bit of code to get the current time and date, and we need a little bit of code to update the TextView with our new time and date.

\paragraph{} Open MainActivity.java. First we need to add some imports so that our app can access the libraries that it needs to do our extra functionality. By default the basic app project only has the minimal set of imports that it needs to display the Hello World message. We have to add other imports to do different things. These are the imports that we need in MainActivity.java in addition to the ones that are already there:

\begin{lstlisting}
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;
import java.util.Date;
\end{lstlisting}

\paragraph{} Now we need to add some code to the onCreate method:

\begin{lstlisting}
Button btn1 = (Button) findViewById(R.id.button1);
        btn1.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                TextView tv1 = (TextView) findViewById(R.id.textView1);
                tv1.setText(new Date().toString());
            }
        });
\end{lstlisting}

\paragraph{} You should now be able to run your app and each time you click the button you will see an updated date and time displayed in the TextView.

\paragraph{} Just for completion. Open the strings.xml file for your app and add a new string resource to represent the text of your button, e.g.

\begin{lstlisting}
<string name="button1">Click Me!</string>
\end{lstlisting}

\paragraph{} Now, in your activity\_main.xml, update the entry for the button to reference the string resource rather than embedding the string directly in the activity, e.g.

\begin{lstlisting}
android:text="@string/button1"
\end{lstlisting}

\paragraph{} Now try to do the same for the TextView. Add a string resource for the default content of the TextView then reference that string resource from activity\_main.xml

\paragraph{} You should now experiment with the various settings that you can use for TextViews and Buttons. Try adding a text view or more buttons and changing the text on them rather than the text on the button being pressed. Use the graphical designer to drag and drop various views onto your activity and use the property inspector to set various properties for the views. Remember to frequently run your app after you have made even small changes to see what effect they have. You should also frequently compare the visual view of the activity which gives you an idea of how the app will look with the contents of the activities XML file. The aim of this is to get a feel for the various widgets that are available, the settings that they can have, and how the views are actually represented as resources in the XML files of your app.

\section{Toasts}
\paragraph{} A toast\footnote{There is more general information about Toasts available at the Android website \url{http://developer.android.com/guide/topics/ui/notifiers/toasts.html} as wells developer documentation \url{developer.android.com/reference/android/widget/Toast.html}} is a view that contains a quick message or notification to the user, the Toast class helps you create and show Toast messages without having to set up the View in a layout file. When the View is shown to the user it appears to float over the current application activity, it never receives focus over and it will not interrupt the users current actions like typing. Examples of common Toast messages are the volume control or save messages when you save a draft of a text message. The idea is to be as unobtrusive as possible while showing important information to the user.

\paragraph{} We can adapt our DateTime app to display a toast each time we click the button. This will illustrate how you can integrate toasts into your own apps. In MainActivity.java we need an import for the Toasts class:

\begin{lstlisting}
import android.widget.Toast;
\end{lstlisting}

\paragraph{} Having imported the Toast class we can use it, which is pretty straightforward. In the onClick handler that we created earlier for our button, just add the following after the call to setText on our TextView

\begin{lstlisting}
Toast.makeText(MainActivity.this, tv1.getText(),Toast.LENGTH_LONG).show();
\end{lstlisting}

\paragraph{} Toasts are also a useful way to do quick output if you want to just check the value of something during development. However there is also a much better way....

\section{Logging}
\paragraph{} Logging\footnote{Developer documentaiton available here \url{http://developer.android.com/reference/android/util/Log.html}} is really important once you start to build larger apps. Because Android doesn't have a console or terminal which our app can output messages to we need something else. We could add widgets into our GUI to let us quickly see the values that our apps hold but this is far from ideal. The logging subsystem is designed to enable you to output data from your app outside of the graphcial views that make up your app.

\paragraph{} Android Studio has areas set aside to display logs whilst you are developing and running your apps. These are in the logcat area and will display both log messages that you cause to be sent from your code, as well as log messages that arise due to errors during runtime.

\paragraph{} To use logging we need some imports again in MainActivity.java

\begin{lstlisting}
import android.util.Log;
\end{lstlisting}

then to cause a line to be written to the log we just need a line like the following (place it in the onClick listener for your button to try it out):

\begin{lstlisting}
Log.i("org.simonwells.datetime","Button pressed");
\end{lstlisting}

\paragraph{} Notice that there are two arguments, the first is our namespace, which you should have set to match either your personal domain name, if you have one, or something like `uk.ac.napier.xx1234' if you created one based on your Napier ID. The second argument is the actual string to write into the log. You could write a static string here as we have done above with `Button pressed' or else you can build the string to display, e.g. including the id of the concerned view so that you can identify exactly which view caused the log line to be created. This is especially useful as your apps get bigger and involve more views (and more things that could go wrong).

\paragraph{} When you run your app and press the button you should see a line similar to the following in logcat:

\begin{framed}
{\scriptsize{
01-21 14:29:21.654 23977-23977/org.simonwells.datetime I/org.simonwells.datetime: Button pressed
}}
\end{framed}

\section{Summary}
\paragraph{} In this practical we have 

\begin{itemize}
\item Investigated the relationship between Android project files made up of Java source files, XML files and others.
\item Displayed text using an Android View
\item Displayed buttons and responded when they have been used
\item Displayed notifications (Toasts) to users
\item Logged output from our apps and viewed it using logcat
\end{itemize}





\chapter{Activities \& Interaction}

\section{Aims}
\paragraph{} At the end of the practical portion of this topic you will be able to:

\begin{itemize}
\item Work with Android Activities
\item Work with user input views
\end{itemize}

\section{Activities}
\paragraph{} We will start the lab by working with activities. Remember that an activity is essentially a window that contains some user interface elements and that an app can have zero or more activities. In HelloAndroid we got a single activity by default that we used to display some views. However, using multiple activities and switching between them can be a useful way to organise your app if you want your user to navigate between multiple screens. So in this part of the lab we will look at creating activities, displaying them, and navigating between them.


\subsection{Creating}
\paragraph{} Creating new activities is straightforward if you are working in Android Studio as it provides helper wizards to add the new code for you. For example, if in the studio interface you right click on the app folder in the project explorer then select ``New'' $>$ ``Activity'' $>$ ``Blank Activity'' and call it `MainActivity2' then studio will add in the necessary code to support your new MainActivity2. This includes a java src file called `MainActivity2.java', an XML activity file called `activity\_main\_activity2.xml', an entry in the AndroidManifest.xml file, and an entry in the strings.xml file.

\paragraph{} But to really get a feel for what is happening we need to do the job by hand. Create a new android project and test that it runs. Add a new Java src file called MainActivity2.java into the same directory as MainActivity.java and edit it as follows:

\begin{lstlisting}
package org.simonwells.multipleactivities1;

import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;


public class MainActivity2 extends ActionBarActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}
\end{lstlisting}
\paragraph{} Compare the code in MainActivity.java to that in MainActivity2.java, how do they differ? What does this tell you?

\paragraph{} Now create a corresponding layout for MainActivity2. In res/layout create a new xml file called `activity\_main2.xml' and edit it as follows:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <TextView android:text="@string/activity2_name" android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

</RelativeLayout>
\end{lstlisting}

\paragraph{} Again, compare activity\_main2.xml to activity\_main.xml and notice the differences between them. Why do you think we did this? Actually, in this case we could have kept the layout file identical but we need a way to differentiate between them once they run, that is why the text references a different string resource.

\paragraph{} That is the bulk of the work necessary to create a new activity. However we are not quite ready to run out app yet. Open strings.xml and add the following to it:

\begin{lstlisting}
<string name="activity2_name">ACTIVITY TWO!!!!???!!</string>
\end{lstlisting}

\paragraph{} Now open you AndroidManifest.xml and add the following below the existing </activity>:

\begin{lstlisting}
        <activity
            android:name=".MainActivity2"
            android:label="@string/app_name" >
        </activity>
\end{lstlisting}

\paragraph{} Your AndroidManifest.xml should now look like this:

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.simonwells.multipleactivities1" >

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name=".MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".MainActivity2"
            android:label="@string/app_name" >
        </activity>
    </application>

</manifest>
\end{lstlisting}

\paragraph{} That is all that is needed to create a new Activity. Two new files, a java source file and an XML layout file, and a couple of edits to make sure that your app knows about the new stuff. You can now run your app.

\paragraph{} Hmmm. Not much difference there? Why do you think that is? 

\paragraph{} Lets edit our AndroidManifest.xml to display the new Activity instead of the default one. To do this we need to add an $<$intent-filter$>$ to our $<$activity$>$ section for the new activity and remove it from the old one, e.g.

\begin{lstlisting}
<intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
\end{lstlisting}

\paragraph{} So your edited AndroidManifest.xml should look like this:

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.simonwells.multipleactivities1" >

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name=".MainActivity"
            android:label="@string/app_name" >

        </activity>
        <activity
            android:name=".MainActivity2"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
\end{lstlisting}

\paragraph{} Now run your app. You should now see the second Activity displayed. You can tell the difference because instead of the ``Hello world!'' message you should see the ``ACTIVITY TWO!!!!???!!'' message. But this isn't really good enough. We can't edit the app's manifest file every time we want to create a new Activity.

\subsection{Starting}
\paragraph{} Create a new Android project to include three activity classes. Up until now we have only been using a single Activity in our applications, now we will be using multiple Activity classes we will need a way to start them. We do this through launching an “intent” and passing in the name of the activity you want to start. Check out http://developer.android.com/guide/topics/fundamentals.html for more information on Intents. Below is some simple code that will start an Activity on a Button click:

\begin{lstlisting}
Button button1 = (Button) findViewById(R.id.button1);
button1.setOnClickListener(new OnClickListener() {
	public void onClick(View v) {
		Intent activityA = new Intent(MainActivity.this, ActivityA.class);
		startActivity(activityA);
	}
});
\end{lstlisting}

\paragraph{} Now create a new class in your project – call it ActivityA. It doesn’t have to do anything in particular, for example – this one just displays a toast so you know you’re now in ActivityA:

\begin{lstlisting}
package com.example.w4p2;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Toast;

public class ActivityA extends Activity {
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_a); //You'll need to create a layout named activity_a
		
		Toast.makeText(getBaseContext(), "In Activity A", Toast.LENGTH_LONG).show();
		//Navigation back is via phones back button
	}
}
\end{lstlisting}

\paragraph{} Then add it to your android manifest file (which says what makes up your project).

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.w4p2"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="8"
        android:targetSdkVersion="17" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.example.w4p2.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name="ActivityA" />
        <activity android:name="ActivityB" />
    </application>
</manifest>
\end{lstlisting}

\paragraph{} Now add a second activity – B – just to try it all out. What if we need to get data back from this new activity? The best way is to use a different method: startActivityForResult (activityA, 1);
So we launch the activity then what? We need a handler to call when our activity has completed. Add this code in your main activity:

\begin{lstlisting}
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    	//Check which request we're responding to - only 1!
    	if (requestCode == 1) {
    		//Make sure request was successful
    		if (resultCode == 1) {
    			String returnString = data.getStringExtra("String");
    			Toast.makeText(getBaseContext(), "In main and string returned = " + returnString, Toast.LENGTH_SHORT).show();
    		}
    	}
}
\end{lstlisting}

\paragraph{} And what does the activity you launch look like now? We have to get the data packaged up as we expect to receive it:

\begin{lstlisting}
String stringToReturn = "Sally Smith";
        Intent returnIntent = new Intent();
        returnIntent.putExtra("String", stringToReturn);
        setResult(1, returnIntent);
        finish();
\end{lstlisting}

\paragraph{} Have a go! If you get stuck ask!

%\subsection{Managing Multiple Activities}
%\paragraph{} Rather than creating a new activity for every screen in your app, it make sense to reuse resources when appropriate. For example, if your user is presented with a list of items that can be displayed, you could either have an activity for each item and switch between them after user interaction, or a single activity, designed to display your items consistently, which is reused based on user interaction. Having less activities, but reusing them in a sensible manner can help to stop your app from becoming unmanageable.


%\section{ViewGroups \& Layouts}
%\paragraph{}


\section{Some User Input}
\paragraph{} Remember, views are widgets that have an appearance onscreen. So user input widgets, such as text inputs, can use views just as output does. Let's explore some user input.

\paragraph{} Create a new project and check that it runs properly. Now delete the Hello World TextView so that we have an empty layout to play with.

\paragraph{} Add a ScrollView such as the following to your layout:

\begin{lstlisting}
<ScrollView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/scrollView"
        android:layout_centerVertical="true"
        android:layout_alignParentLeft="true"
        android:layout_alignParentStart="true"
        android:layout_marginLeft="42dp"
        android:layout_marginStart="42dp" >

        </ScrollView>
\end{lstlisting}

\paragraph{} Your activity\_main.xml should look similar to the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <ScrollView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/scrollView"
        android:layout_centerVertical="true"
        android:layout_alignParentLeft="true"
        android:layout_alignParentStart="true"
        android:layout_marginLeft="42dp"
        android:layout_marginStart="42dp" >
         
    </ScrollView>

</RelativeLayout>
\end{lstlisting}
\paragraph{} Don't worry if everything isn't \emph{exactly} the same. The graphical editor in Android Studio will sometimes try to be helpful and add extra parameters to give you a better layout.

\paragraph{} Now add a LinearLayout as a child of the ScrollView:

\begin{lstlisting}
<LinearLayout
            android:orientation="vertical"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent"
            android:layout_below="@+id/scrollView"
            android:layout_centerHorizontal="true">
</LinearLayout>
\end{lstlisting}

\paragraph{} So you should end up with something like the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <ScrollView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/scrollView"
        android:layout_centerVertical="true"
        android:layout_alignParentLeft="true"
        android:layout_alignParentStart="true"
        android:layout_marginLeft="42dp"
        android:layout_marginStart="42dp" >

        <LinearLayout
            android:orientation="vertical"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent"
            android:layout_below="@+id/scrollView"
            android:layout_centerHorizontal="true">

        </LinearLayout>

    </ScrollView>

</RelativeLayout>
\end{lstlisting}

\paragraph{} Neither of these elements, the ScrollView or LinearLayout do much visually. If you run the app now there isn't much to see. But they are containers which will help us to have a nice screen when we add the views in a few moments. For now, notice how the pair of $<$LinearLayout$>$ $<$/LinearLayout$>$ tags are children of, or come between, the $<$ScrollView$>$ $<$/ScrollView$>$ tags. We will deal with Layouts more in next weeks practical but for now just think of them as containers that holds views for you and automatically arrange them for you. All the ScrollView does is make its child view scrollable when the view won't fit on screen. A ScrollView can only have one child, which is our LinearLayout, but the child of the ScrollView can contain multiple further views. Lets try that out.

\paragraph{} Add three TextViews and three EditTexts to your layout so that you have three pairs of TextView then EditText, e.g. TextView, EditView, TextView, EditView, TextView, EditView in a column down the screen. Make sure to give each TextView and EditView an id so that you can reference each individually.Add strings for your TextViews to display so that the first TextView is the user's name, second is email address, and third is password.

\paragraph{} Your layout should now look similar to this:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <ScrollView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/scrollView"
        android:layout_centerVertical="true"
        android:layout_alignParentLeft="true"
        android:layout_alignParentStart="true"
        android:layout_marginLeft="42dp"
        android:layout_marginStart="42dp" >

        <LinearLayout
            android:orientation="vertical"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent"
            android:layout_below="@+id/scrollView"
            android:layout_centerHorizontal="true">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textAppearance="?android:attr/textAppearanceLarge"
                android:text="@string/name"
                android:id="@+id/tv1" />

            <EditText
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:id="@+id/et1"
                 />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textAppearance="?android:attr/textAppearanceLarge"
                android:text="@string/email"
                android:id="@+id/tv2"
                 />

            <EditText
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:id="@+id/et2"
                android:inputType="textEmailAddress"
                 />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textAppearance="?android:attr/textAppearanceLarge"
                android:text="@string/pw"
                android:id="@+id/tv3"
                 />

            <EditText
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:id="@+id/et3"
                android:password="true" />

        </LinearLayout>

    </ScrollView>

</RelativeLayout>

\end{lstlisting}

\paragraph{} Your strings.xml should look similar to this:

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">UserInput</string>
    <string name="hello_world">Hello world!!!!</string>
    <string name="action_settings">Settings</string>
    <string name="name">Name</string>
    <string name="email">Email Address</string>
    <string name="pw">Password</string>

</resources>
\end{lstlisting}

\paragraph{} All other files in your project should be unchanged for now as we have only edited the layour and strings files, so try running your app now. You might want to futher adjust how things look. It is worth taking the time to do that now as this builds your experience of how Android apps work. When you run the app you should be able to input text into the three EditTexts. The password field should hide letters as you type them in. This behaviour is controlled by the following parameter of the EditText: 

\begin{lstlisting}
android:password="true"
\end{lstlisting}

\paragraph{} You should experiment with the other parameters that EditText, and other views have as you explore the Android platform features.

\paragraph{} Now lets consider doing something with the text entered into the EditText fields. Lets add some features to ensure that the name field is limited to a set number of characters in length and only allows names in upper-case. Open MainActivity.java and add the following code to the OnCreate method after the call to setContentView():

\begin{lstlisting}
    EditText nameTxt = (EditText) findViewById(R.id.et1);
    nameTxt.setFilters(new InputFilter[] {
        new InputFilter.LengthFilter(10),
        new InputFilter.AllCaps()
    });
\end{lstlisting}

\paragraph{} All this is doing is creating a variable, called nameTxt, that is associated with the EditText names et1. We have then used some built in classes to set some filters on the EditText, one of which limits the length of input to 10 chars, and the other which enforces upper-case. Run your app and try it out.

\paragraph{} Now lets do somethings a bit more advanced. Lets check the content of the supplied password to see whether it passes muster. For example, lets assume that the supplied password must contain a mixture of letters and numbers. A simple way to do this is to add a button which, when clicked, will take the text in the password field and tell us whether it is valid. So, add a button to your layout, inside the LinearLayout and after the last EditText:

\begin{lstlisting}
<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/go"
        android:id="@+id/btn1"
        android:layout_below="@+id/scrollView"
        android:layout_centerHorizontal="true" />
\end{lstlisting}

\paragraph{} and add its content to the strings.xml e.g.

\begin{lstlisting}
<string name="go">GO!</string>
\end{lstlisting}

\paragraph{} You can run your app now and the button will be visible but it won't do anything because we haven't given it a handler to response to click events. So lets do that, add the following code to the OnCreate method of MainActivity.java after your code that added the input filters to the name field.

\begin{lstlisting}
final EditText pwfield = (EditText) findViewById(R.id.et3);
    Button go_button = (Button) findViewById(R.id.btn1);
    go_button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            String text = pwfield.getText().toString();

            boolean valid = true;
            boolean hasNumbers = false;
            boolean hasLetters = false;

            for (int i=0; i<text.length(); i++) {
                char x = text.charAt(i);
                if (Character.isDigit(x)){
                    hasNumbers = true;
                }
                else if (Character.isLetter(x)) {
                    hasLetters = true;
                }
                else {
                    valid = false;
                    break;
                }
                if (valid && hasLetters && hasNumbers) {
                    Toast.makeText(getBaseContext(), "Password " + text + " is valid.", Toast.LENGTH_SHORT).show();
                }
                else {
                    Toast.makeText(getBaseContext(), "Password " + text + " is not valid.", Toast.LENGTH_SHORT).show();
                }

            }
        }

    });
\end{lstlisting}

\paragraph{} Most of this is normal Java. You should try to read the code to ensure that you understand exactly what is happening and why.

\paragraph{FURTHER EXERCISE} Try to add a handler for the email field which ensure that the supplied email address is correctly formatted. If you are unsure what constitutes a valid email address then it might be worth finding out more\footnote{\begin{itemize}\item Wikipedia Email Address Page: \url{http://en.wikipedia.org/wiki/Email_address} \item RFC5321 \url{http://tools.ietf.org/html/rfc5321} \item StackOverlfow discussion: \url{http://stackoverflow.com/questions/6119722/how-to-check-edittexts-text-is-email-address-or-not}\end{itemize}}.


\section{Summary}
\paragraph{} In this practical we have 

\begin{itemize}
\item Learnt about Activities
\item Worked with user input
\end{itemize}



\chapter{Layouts \& Visual Design}
\section{Aims}
\paragraph{} At the end of the practical portion of this topic you will be able to:

\begin{itemize}
\item Use layouts to manage the visual organisation of your views
%\item Fragments
%\item Dialogs (using Fragments)
%\item Action Bar
%\item Orientation
\item Design an app using simple graphical tools
\end{itemize}


\begin{framed}
{\bf{NOTICE:}} In this lab we will be dealing a lot with Views, i.e. user interface elements. In Android Studio you have the option of using the graphical layout tool or editing the layout XML files directly. If you use the graphical tool then it might add extra stuff to your layout file as it attempts to ``help'' you. This is OK but might make things display a little peculiarly. You can always remove these extrabits by editing the XML directly within the file. Either way you should be checking what the graphical editor adds to the XML file so that you become familiar with the underlying source code.
\end{framed}

\begin{framed}
{\bf{NOTICE 2:}} Try to avoid copying and pasting code from the practical notes into your editor. You will learn less this way than you do by typing it in yourself. Typing in the code counts as practise. And practising {\bf{always}} makes you better at the thing you are doing.

Copying and pasting has some additional drawbacks: it might introduce subtle errors into your code from copied white space, you will lose formatting so it is harder to comprehend your code, and you will lose the use of the auto-complete feature which sometimes adds in code, such as import statements.
\end{framed}

\section{Android Layouts}
\paragraph{} A layout is a class that manages the way that child views appear on screen. Anything that is a view or inherits from the View class can be a child of a layout. Layouts also inherit from View so they can be nested within each other. We should take note that there are `layout files', the xml files that you find in the res/layout/ folder, e.g.

\begin{framed}
res/layout/activity\_main.xml
\end{framed}

\paragraph{} and there are also Layout Views, graphical elements that you can use within layout files to organise the user interface elements. In this practical we will be using both aspects of layouts. We will be editing layout files and adding Layout Views to them, as well as other kinds of view. However, we will not spend a lot of time building fully working apps. The aim of this part of the practical is to get a solid understanding of how the different Layouts affect the arrangement of views on screen, but we won't necessarily link the views up to Java code that does things with them That is left as an exercise for you, for example, when a button is displayed, cause it to write out a log line in logcat, or display a Toast, just so that you can get some more practise.

\paragraph{} Android includes a number of standard layouts:

\begin{itemize}
\item Frame Layout
\item Linear Layout (in Horizontal \& Vertical flavours)
\item Table Layout
\item Grid Layout
\item Relative Layout
\end{itemize}

\paragraph{} In this practical we will look at a selection of useful Layouts. So, let's get started.

\paragraph{} Create a new Android project and open the activity\_main.xml layout so that you can edit it. Delete the existing ``Hello World'' text view (by clicking on it and pressing backspace. Now add three buttons to the default RelativeLayout. You should end up with something similar to the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="New Button"
        android:id="@+id/button"
        android:layout_gravity="center_vertical" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="New Button"
        android:id="@+id/button2"
        android:layout_gravity="center_vertical" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="New Button"
        android:id="@+id/button3"
        android:layout_gravity="center_vertical" />

</RelativeLayout>
\end{lstlisting}
\paragraph{} That's not ideal is it? All the buttons are placed directly on top of each other. We could give each button a specific position, but this would need to be adjusted for different screen sizes, dimensions, and orientations. It is much better to get the Android framework to manage the layout for us (unless we have something extra special that we want to do that the Android layouts can't manage). So let's try out some Layouts....

\subsection{Linear Layout}
\paragraph{} Delete the three buttons from your activity\_main.xml. Add a Horizontal Linear Layout View to your layout file. You should end up with something like this:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">


    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">
        
    </LinearLayout>
</RelativeLayout>
\end{lstlisting}
\paragraph{} If we run this then we won't actually see very much output as the Layout itself doesn't have any visible view components of its own to display on screen. So we need to add some children to it. Lets put those buttons back but this time as children of the LinearLayout. You should have something like the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">


        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="New Button"
            android:id="@+id/button"
            android:layout_gravity="center_vertical" />

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="New Button"
            android:id="@+id/button2"
            android:layout_gravity="center_vertical" />

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="New Button"
            android:id="@+id/button3"
            android:layout_gravity="center_vertical" />

    </LinearLayout>
</RelativeLayout>

\end{lstlisting}

\paragraph{} Now when you run your app you should see the buttons arranged in a horizontal line across the middle of your screen.

\paragraph{} Now change the orientation parameter of your LinearLayout to vertical so we can try out another orientation of the buttons. 

\begin{lstlisting}
        android:orientation="vertical"
\end{lstlisting}

\paragraph{} When you run the app now you should see that the arrangement of the buttons is in a vertical line but that they are in the top left corner. Let's neaten that up a little by adding a gravity parameter to out LinearLayout:

\begin{lstlisting}
        android:gravity="center"
\end{lstlisting}

\paragraph{} Your vertical buttons should now be centered nicely on screen.

\subsection{Table Layout}
\paragraph{} This is similar to working with a spreadsheet or HTML table. This layout uses TableRow views to organise your views. Create a new project and add a TableLayout to your activity\_main.xml so that you have the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <TableLayout
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

    </TableLayout>
</RelativeLayout>
\end{lstlisting}

\paragraph{} This gives us an empty TableLayout. We now have to populate the table layout with TableRows and those rows need to be populated with actual visible views. Let's do that now; we are going to add three TableRows. In the first cell of the first row we will have a `back' button. In the second cell of the second row we will have a TextView for the user's `First Name' and in the second cell of the second row an EditText. We will have a similar set up for the third row only this time the label for the TextView should be `Last Name'. Your code should look similar to this:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <TableLayout
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

        <TableRow>
            <Button
                android:id="@+id/backbutton"
                android:text="Back"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />
        </TableRow>

        <TableRow>
            <TextView
                android:text="First Name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_column="1" />
            <EditText
                android:width="100px"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />
        </TableRow>

        <TableRow>
            <TextView
                android:text="Last Name"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_column="1" />
            <EditText
                android:width="100px"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />
        </TableRow>

    </TableLayout>
</RelativeLayout>
\end{lstlisting}



\subsection{Relative Layout} 
\paragraph{} If you have built `HelloAndroid' then you have already used the relative layout as it is the default created by the new Android project wizard. Now lets delve a little deeper. Create a new project, open the layout and delete the `Hello World' TextView.

\paragraph{} Now add an EditText, two TextViews, and a Button to your relative layout. Give the EditText an id of ``@+id/name'' and a hint of ``Enter your name''. Give the first TextView an id of ``@+id/date'' and text containg your birthday. Give the second TextView an id of ``@+id/time'' and text of the current time. Finally give your button the text ``done''. Your code should look similar to the following:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <EditText
        android:id="@+id/name"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:hint="Enter your name" />
    <TextView
        android:id="@+id/date"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="05.02.2015"/>
    <TextView
        android:id="@id/time"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="13:01 PM"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Done" />

</RelativeLayout>
\end{lstlisting}

\paragraph{} Obviously if you run this, those views will all be placed on top of each other as we haven't told the RelativeLayout how to lay out the view \emph{relative} to each other.

\begin{framed}
Good practise would be to use the strings.xml to hold the values of your views, e.g. yourEditText, TextViews, and Button - but I have not done that here just to try to keep the example code as straighforward as possible.
\end{framed}

\paragraph{} I think we should have the EditText at the top of the screen, with the two text views aligned in a row immediately below it. We should then have the button positioned below the TextViews. So let's do it. We need to add some parameters to our views to tell them where they should be positioned relative to each other. Lets start with the EditText and work our way along:

\begin{description}
\item[EditText] This is the easiest, it is the first item to be placed and so doesn't need any extra parameters to describe its location relative to other views.
\item[TextView `date'] We want this view to be below the name view (our EditText). We want it to be aligned to the left of the parent view, and left relative to the other TextView `time' so it needs the following parameters:
    \begin{lstlisting}
        android:layout_below="@id/name"
        android:layout_alignParentLeft="true"
        android:layout_toLeftOf="@+id/times"
    \end{lstlisting}
\item[TextView `time'] We want this to be below the EditText and aligned to the right of the parent layout so we can use the following parameters:
    \begin{lstlisting}
        android:layout_below="@id/name"
        android:layout_alignParentRight="true"
    \end{lstlisting}
\item[Button] We want to position this below the TextViews and centered in the parent layout so can use the following parameters:
    \begin{lstlisting}
        android:layout_below="@id/time"
        android:layout_centerInParent="true"
    \end{lstlisting}
\end{description}

\paragraph{} As a result our layout file, activity\_main.xml should look something like this:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <EditText
        android:id="@+id/name"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:hint="Enter your name" />
    <TextView
        android:id="@+id/date"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/name"
        android:layout_alignParentLeft="true"
        android:layout_toLeftOf="@+id/time"
        android:text="05.02.2015"/>
    <TextView
        android:id="@+id/time"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/name"
        android:layout_alignParentRight="true"
        android:text="13:01 PM"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/time"
        android:layout_centerInParent="true"
        android:text="Done" />

</RelativeLayout>
\end{lstlisting}

\paragraph{} You can use the ids of each view to follow the layout of each relative to an earlier view, e.g. @+id/date is laid out below @+id/name and to the left of @+id/time.

\paragraph{} As an exercise, write Java code to display respectively the current date and time automatically in the two TextViews. Add functionality so that on pressing the button a unique Toast message is create which combines the user's name with the date and time, e.g. ``Hello Selina Kyle, it is now 13:01PM on 05.02.2015''

\subsection{ListView}
\paragraph{} This is a view which groups items and displays them in a scrollable, vertical list. This is a really useful and common interaction pattern on Android so we should become familiar with it. However it is a little more complicated that using a basic Layout.So we will build a complete app that displays a scrollable ListView containing a list of colours of the rainbow. You can of course make a list of whichever items you want.

\paragraph{} Create a new Android project and delete the `Hello World' TextView. First, in activity\_main.xml we need to add our ListView. We can do it like this:

\begin{lstlisting}
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <ListView
        android:id="@+id/colour_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >
    </ListView>

</RelativeLayout>
\end{lstlisting}

\paragraph{} We now need to add a new Java Activity file and associated Layout XML file like we did in the last practical. We will call our Activity listview, so we need a listview.java file which should be very similar to the default MainActivity.java file. It should look similar to this:

\begin{lstlisting}
package org.simonwells.layouttest01;

import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;


public class listview extends ActionBarActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_listview);
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_listview, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}
\end{lstlisting}

\paragraph we need to create the layout XML file for our listview Activity so we need a layout in res/layout called activity\_listview.xml which should contain the following:

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<!--  Single List Item Design -->
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/label"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:padding="10dip"
    android:textSize="16dip"
    android:textStyle="bold" >
</TextView>
\end{lstlisting}

\paragraph{} This second layout is essentially just the content of each element of the listview that will be displayed. We also need to add the following entry to the other entries in strings.xml

\begin{lstlisting}
<string name="title_activity_listview">listview</string>
\end{lstlisting}

\paragraph{} And edit our AndroidManifest.xml to include the new Activity:

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.simonwells.layouttest01"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="10"
        android:targetSdkVersion="21" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="org.simonwells.layouttest01.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="org.simonwells.layouttest01.listview"
            android:label="@string/title_activity_listview" >
        </activity>
    </application>

</manifest>
\end{lstlisting}

\paragraph{} Now finally, we can link all these bits together by editing MainActivity.jaava. We want to do two things. Firstly, populate the ListView, and secondly, react to clicks on the list by displaying a Toast of the list contents. Our MainActivity.java should look like this:

\begin{lstlisting}
package org.simonwells.layouttest01;

import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;


public class MainActivity extends ActionBarActivity {
    String[] colourArray = {"Red", "Orange", "Yellow", "Green", "Blue", "Indigo", "Violet"};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ArrayAdapter adapter = new ArrayAdapter<String>(this,
                R.layout.activity_listview, colourArray);

        final ListView listView = (ListView) findViewById(R.id.colour_list);
        listView.setAdapter(adapter);

        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                String selection = (String) (listView.getItemAtPosition(position));
                Toast.makeText(getApplicationContext(), selection, Toast.LENGTH_SHORT).show();
            }
        });
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}
\end{lstlisting}

\paragraph{} You can now run your app. Assuming that everything has right you should now be able to view a scrollable list of colours of the rainbow (or whatever else you put in the list). We haven't gone into as much detail explaining what is happening in the ListView as in other examples. This is because it is mostly built from things we have already seen. It is a combination of basic views, layouts, and activities glued together with a bit of Java. Once you have it running you should spend some time getting an understanding of how it all fits together.

\paragraph{} In summary, layouts are a powerful and useful way to build flexible and dynamic layouts for your app and are, as a rule, much preferred over hard coding the layouts, especially when dealing with different screen sizes.



%\section{Dialogs (using Fragments)}
%\paragraph{} By default an activity occupies the entire screen. However you can apply a dialog theme so that your activity is displayed as a floating dialog which can sometime be useful to warn users or to double check that a user is sure of their action (when an action could have potentially bad consequences such as deleting data).

\section{Designing Apps}
\paragraph{} You shouldn’t spend months on your app before checking if the design will work. The use of storyboards and navigation maps followed by a rapid development application development tool will help you mock up a template to test your design early on and hopefully find any flaws with your design.

\paragraph{} We will design a home page (default activity displayed when an app is launched by clicking its icon) for an app. You can base this on your coursework idea (if you have one) or any other app that you would like to consider. If you don't have any ideas or want to try something different then perhaps design the home-page for a weather display app:

\begin{framed}
Assume that you have an API available which will allow your device to remotely retrieve information about the weather conditions and perhaps forecast for a named area, e.g. Edinbugh. You can use the data returned by the API of OpenWeathermap\footnote{\url{openweathermap.org}} as an exemplar of what data might be available to you. Design a home page to display this data, or a sensible subset, to your user.
\end{framed}

\begin{itemize}
\item Start will a storyboard for a layout, we will need a home page that will link to a photo gallery of attractions, a page that will link to various tourists sites and a page about our application itself.
\item Decide on a prototyping tool such as PhoneGap\footnote{\url{http://phonegap.com/}}, App Inventor\footnote{\url{http://appinventor.mit.edu/}}, using the XML layout designer in Android Studioor any other tool you feel comfortable using, NB. Try a search for ``Android Wireframe Mockup tools'' and you will be surprised by the number available\footnote{\url{http://mashable.com/2013/04/02/wireframing-tools-mobile/} is a good place to start}. If you are not sure where to start then try the XML Layout Designer of Android Studio as it is already installed in the labs. If you are still unsure there are plenty of comparison articles available online\footnote{\url{http://www.amlcode.com/2010/07/16/comparison-appinventor-rhomobile-phonegap-appcelerator-webview-and-aml/}}.
\item Try and develop the basic layout to the Weather App from above. Alternatively,  spend the time trying to prototype your own coursework app.
\end{itemize}

\section{Summary}
\paragraph{} In this practical we have: 

\begin{itemize}
\item Explored Android Layouts and Views for managing how your UI is displayed.
\item Begun prototyping Android apps using appropriate prototype and mockup tools.
\end{itemize}


\part{Notes}
\chapter{Introduction to Mobile Computing} 

\section{Aims}
\paragraph{} At the end of this topic you will be able to:

\begin{itemize}
\item Explain where ‘mobile app’ development fits into the recent history of computing \& mobile computing. 
%\item Develop an Android app % In 2016 will include Hello Android but not in 2015
\end{itemize}


\section{The Rise of Mobile Computing}
\paragraph{} Today's mobile phone owes its origins to radio phones which were introduced on first class passenger trains in Germany in 1926. Mobile technology was enhanced during WW2 when Motorola created a walkie-talkie for the US Army – which was carried in a backpack to house the huge batteries.

\paragraph{} Following the development of cell-based transmitters and receivers in the late 1940s, the 1950s saw car phones making use of this cell technology although calls were not continuous as the car travelled from one cell to the next.

\paragraph{} In 1956 Ericsson created the first system that did not require manual control in the base stations in Sweden. Unfortunately the phone weighed 40 kilograms so not mobile in the sense we understand today.

\paragraph{} Until 1970 mobile technologies continued to be developed mainly in US and USSR. In 1971 an engineer from Bell Labs found a solution for transferring the call from a network to another without loss of communication. In 1973 Motorola made its first call on a truly mobile phone, illustrated in Figure \ref{fig:brick-phone}, – which is now referred to as the first generation. After specialising in military communications, Vodaphone launched the UKs mobile network in 1985. By the mid to late 1980s the mobile phone was the must have status symbol of business wheelers and dealers in Thatcherite Britain.

\begin{figure}[htb]
\centering
\includegraphics[width=0.5\textwidth]{images/brick-phone}
\caption{Motorola's mass marketed phone from 1973}
\label{fig:brick-phone}
\end{figure}

\paragraph{} In the 1990s the second generation of phones appeared – introducing digital technology in the form of GSM (Global System for Mobile communications) into the networks. In Europe Nokia was a key developer of GSM and the first GSM network was opened in Finland. This second generation of mobile phones introduced the SMS service – arguably the start of social networking. Customisation started here – with downloadable, if expensive, ring tones – and business users were overtaken by the general population driven by a huge interest from younger users.

\paragraph{} Third generation networks \& devices appeared in Japan in 2001. The main aim was to satisfy the demand for data services  i.e. move to packet switching to speed things up so we could get internet-on-the-go, swap photos and video. The i) mobile phone and ii)PDAs/ netbooks with dongles started to converge with the smartphone emerging as the product of their convergence. 

\paragraph{} The fourth generation is fast approaching – VoIP will replace traditional circuit switched calls in a network optimised for data services. At the moment it’s just a marketing term.

\section{Recent History of Mobile Computing}

\begin{itemize}

\item The first commercial laptop illustrated in Figure \ref{fig:grid-compass}, the GRiD Compass\footnote{\url{http://en.wikipedia.org/wiki/Grid_Compass}} started selling in 1982 at a price tag of \$8000 the main customer was the US Department of Defence and NASA.

\item Personal Digital Assistant was a term used to describe the Apple Newton  illustrated in Figure \ref{fig:apple-newton}, first sold in 1992. PDAs could keep calendars, play games, synch with your desktop. Although there was a proliferation of manufacturers' operating systems, the Symbian OS came to dominate, with MS following with their Microsoft CE OS.

\item The Nokia 9000  illustrated in Figure \ref{fig:nokia-9000}, was released 1996. A phone which could send/receive emails and type up Word docs. Arguably the world's first smartphone.

\item In 2002, Blackberry manufacturers Re-search in Motion (RIM) released their first smartphone,  illustrated in Figure \ref{fig:rim-blackberry}, following their successful push email technology. Popular amongst business users originally, the Blackberry found a new market amongst teenage girls thanks to the BlackBerry Messenger app, before declining in popularity.

\item The first Apple iPhone, illustrated in Figure \ref{fig:apple-iPhone}, was released in June 2007. The latest version, 4, was released in July 2010 (following the iPad release in April 2010). The iPhone was the first smartphone with mass market appeal.

\item In October 2008, the first Android phone – the HTC Dream (aka T-Mobile G1), illustrated in Figure \ref{fig:android-phone}, – was released. This was followed by the HTC Hero and now HTC Desire \& Samsung Galaxy, among others. Encouraged by the open nature of the development kit, this is creating a garage app developer culture.

\end{itemize}

\begin{figure}[htb]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/grid-compass}
                \caption{GRiD Compass}
                \label{fig:grid-compass}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/apple-newton}
                \caption{Apple Newton}
                \label{fig:apple-newton}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/nokia-9000}
                \caption{Nokia 9000}
                \label{fig:nokia-9000}
        \end{subfigure}
        \caption{The GRiD Compass, Apple Newton, \& Nokia 9000}\label{fig:early-mobile-platforms-1}
\end{figure}

\begin{figure}[htb]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/rim-blackberry}
                \caption{RIM Blackberry}
                \label{fig:rim-blackberry}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/apple-iphone}
                \caption{Apple iPhone}
                \label{fig:apple-iPhone}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{images/android-phone}
                \caption{Android Phone}
                \label{fig:android-phone}
        \end{subfigure}
        \caption{The Blackberry, iPhone, \& Android}\label{fig:early-mobile-platforms-1}
\end{figure}



\paragraph{} \emph{Where are we now?} The line between communication and computation has become increasingly blurred. A smartphone is now a handheld computer with integrated mobile phone (and pager, compass, camera, GPS, torch, ...)

\begin{quote}
"I have always wished for my computer to be as easy to use as my telephone; my wish has come true because I can no longer figure out how to use my telephone." 
— Bjarne Stroustrup  (Danish inventor of C++)
\end{quote}

\paragraph{} What do we expect of our mobile computing devices?
\begin{itemize}
\item phone
\item touchscreen or at least easy character entry
\item email
\item camera \& memory to save photos
\item audio \& video recorder \& player
\item web browsing
\item app platform eg games
\item reasonable battery life
\item small?
\end{itemize}

\paragraph{} Less discerning about:
\begin{itemize}
\item price - not necessarily cost conscious, at the moment
\item shelf life
\end{itemize}

\paragraph{} So what's the current state of play? Check with Gartner, market analysts. Android phones and iPhones continue to increase their market share.  New markets include the developing world – Huawei Telecom in China are manufacturing cheap Androids for India and Africa. There is also growth in iPad/ Android tablets.
 

 %%
 %%
 %% INSERT SECTION ON GARTNER SALES FIGURES
 %%
 %%
 %%


 \paragraph{} To a large extent the availability of apps is driving these increases for the iPhone and Android. Blackberry launched their own apps market and saw some growth in their handset sales. Meanwhile Symbian have opened up their OS. Huawai Telecom have launched a cheap Android phone in India – the Ideo. It’s hard to see a way for the iPhone to reach the developing world.


\section{Summary}
\paragraph{} In this topic we have attempted to understand why mobile computing and communication have become popular now by studying longer term trends in the wider fields of computing and communication.

\section{Directed Study}
\paragraph{} 

\begin{itemize}
\item Read Chapters 1 to 3 of Android Wireless Application Development \cite{conder_2010_android_ebook}.
\item Read more about the history of mobile computing, for example the Wikipedia page on the history of mobile phones is a good place to start\footnote{\url{http://en.wikipedia.org/wiki/History_of_mobile_phones}}.
\item Visit the developers website http://developer.android.com
\item Check your understanding of the topic by answering the following:
\begin{enumerate}
\item Name three apps you have used/ heard about and identify the platform they run on?
\item What makes a good app?
\item In Android-speak, what is an activity?
\item How do Intents work?
\end{enumerate}
\item If you have access to a computer at home, download and install the Oracle Java JDK\footnote{\url{http://www.oracle.com/technetwork/java/javase/downloads/index.html}} then install the Android development tools\footnote{\url{http://developer.android.com/sdk/index.html}}.
\item Have a look at the App Inventor\footnote{\url{http://appinventor.mit.edu/}}  – what do you think – can this revolutionise app development? It was initially developed by Google then, when abandoned, MIT stepped in.
\end{itemize}


%\section{Resources}


\chapter{Platforms \& Lifecycles}

\section{Aims}
\paragraph{} At the end of this topic you will be able to:

\begin{itemize}
\item Describe what Android is
\item Describe and use the Android SDK
\item Select and use an IDE
\item Understand the components of an Android App
\item Understand the Activity life-cycle
\end{itemize}

\section{Introducing Android} 
\paragraph{} As you can see we have lots of options for how to develop software for mobile devices. For the practical part of this module, we are going to use Android.

\begin{framed}
\begin{quote}
Android is Google's operating system for mobile devices based on ARM architecture. It is a competitor to the Symbian platform, Apple's iOS for the iPhone and Microsoft's Windows Mobile and Windows Phone for mobile devices all based on ARM architecture.
Android sits on a modified Linux kernel and includes middleware which allow you access to the hardware and key applications. It lets you develop Java but, as with applets on the web, there are some constraints and a philosophical framework.
The Android operating system software stack consists of Java applications running on a Java based object oriented application framework on top of Java core libraries running on a Dalvik virtual machine featuring JIT compilation. … The Android operating system consists of 12 million lines of code including 3 million lines ofXML, 2.8 million lines of C, and 2.1 million lines of Java
\end{quote}

{\begin{flushright}Source: Wikipedia\\\url{http://en.wikipedia.org/wiki/Android_(operating_system)}\end{flushright}}
\end{framed}

\paragraph{} Android was launched by Google/Open Handset Alliance in November 2007 with a competition for developers to design and build prize winning apps – they offered \$1m in prize money. This kick started the Android marketplace. One of the winning apps was an automatic taxi ordering service which read your location in New York and with a single button press ordered a taxi to pick you up; perhaps reason enough to buy a phone?\footnote{See more winners at \url{http://code.google.com/android/adc/gallery_winners.html}}


\section{Development Tools}
\subsection{The SDK}
\paragraph{} The Android SDK is the core set of tools that the Android project have released so that we can develop our own Android apps. The SDK is a mix of tools, that work primarily from the command line, and libraries, which your code can hook into to make use of Android platform features. Whilst the tools work from the command line, there is additional software that you can use to provide graphical user interfaces to the Android tools. For example, Android Studio is an Integrated Development Environments (IDE) which provide a graphical development environment to the command line tools of the SDK. You can build Android apps using only the SDK, however many developers feel more comfortable using an IDE.

\subsection{Development Environments}
\paragraph{} Since December 2014 when version 1.0 was released, the main IDE for Android development has been Android Studio. Prior to this the main IDE was Eclipse, a popular Java development IDE with additional plugins to support Android development. 

\subsection{The Android Debug Bridge}
\paragraph{} Because Android apps are designed and built to run on devices using the Android OS, and not your desktop OS such as Linux, Mac OS, or Windows, you need to provide a way for any apps that you produce to run so that you can test them. For this you have a few options, but you must do at least one of these if you want to be able to run your Android app (and determine that it runs correctly):

\begin{enumerate}
\item The Android Emulator/Android Virtual Device (AVD) - Your IDE provides tools that allow you to run a program that emulates an Android device. In Studio these can be found under Tools $>$ Android $>$ AVD Manager. AVD stands for Android Virtual Device which is the emulated version of the Android OS. Use the AVD Manager to create new devices with various hardware capabilities and software levels. However you should note that emulation is very very very slow. In particular on lab machines, which are running the emulation across the network, you must create AVDs which are very conservative in their hardware, e.g. use lower amounts of RAM, 256MB should be sufficient for most lab practicals, and which use a smaller screensize, e.g. 
\item Hardware - If you have an Android device then you can enable the USB Debugging mode, plug it into your development machine, and it should appear as a connected device which you can select as a target to run your app on. This mode is hidden in a different place on different Android devices so you might have to do a web search for your ``device name+model+enable USB debugging mode''. On OS X and Linux this should 'just work'. On Windows you may have to install drivers for your mobile device before it can be recognised and used to debug Android apps.
\item Virtual Machine - Genymotion\footnote{\url{https://www.genymotion.com/}} is probably the best third party solution for faster virtual Android devices. Underneath it uses the VirtualBox virtualisation software and is much faster than the AVD approach.
\end{enumerate}


\section{Architecture of the Android Platform}
 
\begin{figure}[htb]
\centering
\includegraphics[width=\textwidth]{images/architecture-android}
\caption{The architecture of the Android platform}
\label{fig:architecture-android}
\end{figure}

\section{The Components of apps}
\paragraph{} Android has been designed to let developers take advantage of all the hardware nestling inside your phone. It does this through activities which “do stuff”, services which “do background stuff”,  reusing another app’s functionality (if granted permission) and publishing functionality. Specifically an application is made up of components and a messaging service to communicate between them:

\subsection{Activities}
Think of as a single view or window and one per screen – you can move pages by launching another activity. User interface components are called Views and include scroll-bars, text strings etc (similar to swing components in Java or controls in VS).

\subsection{Services}
A service doesn't have a visual user interface. They run in the background. For example, a service might play background music. Each service extends the Service base class.

\subsection{Broadcast Receivers}
A broadcast receiver is a component that responds to system-wide announcements, for example, that the music player has been switched on, that the battery is low. Your app can also broadcast some information for other apps running on the phone – and interested apps can, as BroadcastReceivers, receive the message (eg change of timezone) and apps can also be BroacastReceivers by extending the BroadcastReceiver base class. You might want to notify the user - through the NotificationManager. These notifications appear on the status bar.

\subsection{Content Provider}
A wrapper for databases and files, the content provider can make app data available to other apps

\section{The Activity Lifecycle}


\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{images/android_lifecycle_original}
\caption{The lifecycle of Android activities.}
\label{fig:lifecycle-android-activities}
\end{figure}


\begin{figure}[htb]
\centering
\includegraphics[width=\textwidth]{images/android_lifecycle_state-diagram}
\caption{A slightly re-arranged diagram of the lifecycle of Android activities.}
\label{fig:lifecycle-android-activities-state-diargram}
\end{figure}



\paragraph{} Activities and services are activated by intents. Intents are asynchronous messages used by the OS to match task requests with activities and services. The Intent object is a bundle of information: it ``contains information of interest to the component that receives the intent (such as the action to be taken and the data to act on) plus information of interest to the Android system (such as the category of component that should handle the intent and instructions on how to launch a target activity)''\footnote{\url{http://developer.android.com/guide/topics/intents/intents-filters.html}}.


\paragraph{} Instead of a main method defining where things kick off, you must define a class which extends (or inherits from) Activity. An Activity class simply means that it can run and do stuff.
The onCreate() method will be called when your Activity starts — it is where you should perform all initialization and UI setup. The onCreate() method will be called by the Android system when your Activity starts — it is where you should perform all initialization and UI setup. [The @Override statement is a Java convention - it simply flags up your intention to override a method in the superclass so the compiler can check that’s what you actually end up doing – and flag it if that’s not what the net effect is.] The Bundle is a mechanism for living with the complexity of multiple activities, multiple entry points etc. The bundle refers to the data required to run your activity effectively – eg what is the current state of your activity, have you been interrupted by a phone call for example.
A View is a drawable object eg button, image or, in this case, some text. TextView is a subclass of view. We construct a TextView object (tv). The constructor parameter this refers to is an Android Context. A Context is a handle to the system – providing preferences, access to databases etc. The Activity class inherits from the Context so this is a context.  
The app then calls the setText() method of the tv object.
Finally, you pass the tv to setContentView() in order to display it as the content for the Activity UI. If your Activity doesn't call this method, then no UI is present and the system will display a blank screen.




\section{Summary}
\paragraph{} In this topic we have learnt to:

\begin{itemize}
\item Describe what Android is
\item Describe and use the Android SDK
\item Select and use an IDE
\item Understand the components of an Android App
\item Understand the Activity life-cycle
\end{itemize}


%\section{Directed Study}
%\paragraph{}

%\section{References \& Resources}

\chapter{Mobile User Experience}

\section{Aims}
\paragraph{} At the end of this topic you will be able to:

\begin{itemize}
\item Use design patterns to communicate your designs
\item Use and understand platform guidelines
\item Evaluate your application
\end{itemize}

\paragraph{} Whilst there are many core lessons to be learnt from human factors research about the best ways to design software for different users which are generally applicable, it is also true that the mobile platform offers some aspects of the user experience which are particular to the mobile context. For example, the close integration of a wide array of physical sensors, human and machine oriented communication support, wide-variety of screen sizes, touch interface, lack of hardware keyboard, wireless/untethered operation, and pure ubiquitousness provide both unique opportunities to take advantage of and novel pitfalls to avoid.


\section{Design Patterns}
\paragraph{} Design patterns can be considered as an attempt to build a shared language for describing solutions to problems. They were originated in the architectural research discipline by Christopher Alexander who coined the term ``Pattern Language''. An individual pattern describes a problem, and a solution. Importantly, patterns were originally specified as `timeless' e.g. they didn't make assumptions about the adoption of a particular technology or intricate solution to a one-off issue, but were more about dealing with recurring problems that have accepted and acknowledged solutions that are both beautiful and practical. A key element of patterns is the idea of language. A collection of design patterns forms a shared language for communicating ideas about recognising and solving problems. By having a shared language people, any people, not just experts, can understand and contribute towards the solution of the problem.

\subsection{Patterns as a Dictionary of Decisions}
\paragraph{} One nice way to describe patterns is as entries in a dictionary. When a designer creates a design they make decisions about how to solve problems. Often these problems and solutions recur many times in many contexts. A pattern is thus a single, documented problem and its most common, recognised, good solution. Each pattern is named, described, and cross-referenced to related patterns similar to entries in a dictionary. In this way the collection of patterns form a language, having syntax, the description of individual patterns, grammar and semantics, captured by the relations between patterns.

\paragraph{} The idea of pattern languages was borrowed by Software Engineers in the 1990s who started applying the idea of recurring and reusable solutions to the design and development of computer software.

\paragraph{} The Android platform, like software design in general\footnote{The Portland Pattern Repository found at \url{http://c2.com/cgi/wiki?WelcomeVisitors} is probably the best online resource about software design patterns. Interestingly it was also one of the first Wikis on the web. Of course the best `dead tree' edition is the `gang of four book' \cite{gamma_1994_design.patterns}. However this book is aimed at experience software engineers so a better place to start might be the `Head First Design Patterns' book \cite{freeman_2004_head.first.design.patterns}} has it's own sets of design patterns\footnote{\url{https://developer.android.com/design/patterns/index.html}} related to patterns of interaction with Android user interface elements.

%\section{Design Patterns for Mobile \& Android}


\section{Style Guides}
\paragraph{} Recently, the Android project has developed Material Design\footnote{\url{https://developer.android.com/design/material/index.html}}, a guide for visual, motion, and interaction design across platforms and devices. Similarly Apple has had the iOS Human Inteface Guidelines \footnote{\url{https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/}} for many years. The aim of these guide is twofold. Firstly, to build on the same ideas as design patterns by giving everyone an agreed language for sharing and communicating aspects of our designs. Secondly, style guides define a baseline for designing software for their respective platforms. If the guides are followed this leads to greater cohesion of apps across the platform which shows respect for users by matching their expectations. Of course, the recent popularity of touch interfaces and design to suit the vagaries of differing mobile platforms means that most of these style guides are in flux. They are living documents which are regularly updated to try to capture best practise as we learn and discover new and better ways to build and use mobile apps.


\section{Evaluation}
\paragraph{} You should not leave evaluation of your app until the very last moment as it is then far too late to fix any basic errors in usability or misunderstandings of your target users. So you should evaluate early and often. For now, we will assume that we are evaluating a prototype at some stage of its development from basic layout with little functionality (lo-fi – low fidelity) to almost the final product (hi-fi prototype).

When you have conducted your evaluation, made any changes, re-tested - you’re good to go - deploy \& market (something we will look into towards the end of the module).

\subsection{Evaluation Techniques}

\begin{quote}
``Evaluation is about humility'' Jones \& Marsden
\end{quote}

\paragraph{} Leave your ego outside the usability lab and hope it won't be an exercise in complete humiliation. Here are a few techniques presented in order from basic lo-fi prototype being required up to techniques for evaluating a near-finished product :

\subsubsection{Quick feedback}
\paragraph{} Completely unscientific, but useful for some informal feedback on a lo-fi prototype – simply get a few typical end-users together and show them your work. Take notes. Use this to check your ideas aren’t miles out.

\subsubsection{Conceptual Model Extraction}
\paragraph{} Use storyboard sketches or a lo-fi model to show to users. Ask them to explain what they think you are trying to convey. For example, look at the Android emulator or phone homepage. Should settings be a couple of cogs? The users should be able to extract your conceptual model from your prototype/ sketches.

\subsubsection{Direct Observation}
\paragraph{} Give users some instructions and your prototype and observe how well they manage to undertake your tasks. You might ask them to think aloud and record their thoughts on a Dictaphone (or your phone) or you could video the session so you can observe without taking notes and reply later. You can use a log to capture the users' interactions – use the logging feature of Android to provide a trace of where the user went in your app and how long they stayed there. Heat maps are also interesting but they are not yet commonplace for mobile devices:

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/heatmap}
\caption{Heatmap used to visualize where a users eyes spend their time}
\label{fig:heatmap}
\end{figure}

\paragraph{} In any evaluation, even if it’s for your coursework, look after your users:
\begin{itemize}
\item Follow any ethics guidelines eg don’t expose children to inappropriate material or excessive volume etc
\item Explain what you want and why
\item Treat them with respect – e.g. don’t roll your eyes if they get it all wrong
\item Let them withdraw if they have had enough
\item Reward them – be prepared to pay them – or if it’s a coursework reciprocate
\end{itemize}

\subsubsection{Interviews}

\paragraph{} Rather than just observing users - ask them what they think, why they approached tasks in the way they did etc. This can follow on from observation or, if you can’t observe for some reason, can be used as a substitute.

\subsubsection{Questionnaires}
\paragraph{} Everyone loves a good questionnaire. I know - you hate them - but for the developer they are easy and can reach a wide audience. The questionnaire returns can usually be analysed quantitatively (eg ``30\% got to the app icon first go'', ``18\% agreed that the text was easy to read''). Don’t just throw together some questions in five minutes - you only get one chance - study the theory of questionnaire design. It’s easy to make a mess of it and then you have lost your opportunity to gain valuable feedback.

\paragraph{} The following are some guidelines for good practice in questionnaire design:
\begin{itemize}
\item The complexity of your questionnaire and its language should take into account the age, education, competence, culture, and language abilities of respondents.
\item Consider using:
\item E-mail – fast, inexpensive, not anonymous.
\item Telephone – time consuming, not anonymous, may require skill, has to be short.
\item Face-to-face interview – slow, expensive, requires skill, best for small samples, qualitative studies.
\item Web-based – fast, inexpensive, can be anonymous, best for large surveys, for example use http://www.surveymonkey.com
\item Explain the purpose of the work – emphasise that it’s a worthwhile use of their time and they are contributing to something worthwhile and their feedback is important. Thank them too.
\item Keep it short and let them know how long it’ll take.
\item Use a good structure – group questions into sections. Let them skip or backtrack.
\item Keep response options simple, for example, use scales that provide useable granularity or consider a Lickert scale\footnote{\url{http://en.wikipedia.org/wiki/Likert_scale}}.
\item Be consistent don’t use a 5-point scale in one question and a 7-point in the next.
\item If you use a continuum scale with numbers for answer options, use a clear concept at the top and bottom of the scale (eg “on a scale of 1 to 5, how good is it? : where 1=very bad and 5=very good).
\item Use scales that are centred– don’t have one “bad” answer option and four shades of “good”.
\item Don’t force respondents into either/or answers if a neutral position is possible
\item ``Not applicable'' or ``don’t know'' responses should be available
\item Open responses are difficult for you to consolidate, so use them sparingly – but they can sometimes provide the best information, eg “what would you change?” but don’t force them to answer.
\end{itemize}

\subsubsection{Usability experts}
\paragraph{} Employ a trained usability expert and draw on their training and expertise. They would be considering the following heuristics (ie applying their experience gained/ knowledge to a problem) (Jones \& Marsden, 2006):

\begin{itemize}
\item Visibility of system status – does the user know where he is, what’s going on
\item Match between system and real-world – is the language right
\item User control and freedom – support undo/redo to help users who make mistakes
\item Consistency and standards – follow Android/ iPhone conventions
\item Error prevention – better to prevent than report errors eg restrict input
\item Flexibility and efficiency – responsiveness for users, let them tailor frequent actions
\item Aesthetic/ minimalist design – don’t overdo prompts etc
\item Recovery – help users recover if stuck or make a mistake
\item Help \& documentation – timely, appropriate help
\end{itemize}

\subsubsection{Experimental Evaluation}
\paragraph{} Here we try to evaluate our app with something similar. For example, compare Android  with iPhone. We pick one metric eg user errors and conduct a series of experiments such as asking the user to open a browser and find a site. You then use statistical analysis on recorded keypresses/ clicks to determine if the users were more likely to make an error using iPhone than Android then how long they took to overcome the error. 

\paragraph{} How do you know if the data is right about which would cause the fewest errors?  The skill is in the design of the experiment and the analysis tools used.

\subsection{Case Studies}
\subsubsection{Smart Diet}

\paragraph{} A group of researchers from Seoul, Korea developed a SmartDiet app then setup an experiment with 19 overweight people who used the app and a further 17 people who were asked to lose weight without the app\footnote{\url{http://jtt.rsmjournals.com/cgi/content/abstract/16/5/270}}. Overall, the researchers found that ``the SmartDiet mobile weight management application appears to contribute to weight loss in obese adults''.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/smart-diet-1}
\caption{Smart Diet Launch Screen}
\label{fig:smart-diet-1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/smart-diet-2}
\caption{Smart Diet UI}
\label{fig:smart-diet-2}
\end{figure}

\subsubsection{M-AID}

\paragraph{} An app to support emergency medical treatment\footnote{\url{http://journals.lww.com/ejanaesthesiology/Fulltext/2007/06001/Evaluation_of_M_AID,_a_mobile_phone_first_aid.619.aspx}}

\paragraph{Background and Goal of Study} ``Cardiopulmonary resuscitation (CPR) by bystanders has been shown to reduce mortality due to sudden cardiac arrest when it is effectively performed.'' A mobile app detailing the steps for diagnosis and treatment was developed – called M-AID. The study wanted to see whether it was useful in an emergency situation.
Normally evaluation studies would need to compare against a control group. So if a new drug is developed they need one group to take the placebo to check whether the improvements are real or perceived.
Ethically, you can’t give 100 people the app and 100 people a dummy app and count the lives saved so they designed a scenario-based experiment – or simulated instances of cardiac arrest. The test group had the M-AID app and the control group didn’t have the app.

\paragraph{Materials and Methods} ``119 volunteers were randomly assigned either to the test or the control group. All participants had to manage the same emergency scenario - acute coronary syndrome leading to cardiac arrest. The participants were either equipped with a mobile phone running M-AID (test group) or had to handle the situation without any support (control group).''
The experiment was observed – with points allocated for each correct action taken. The scores were then compared. Some statistical levelling was introduced according to the participant’s medical training and experience. The participant’s mobile phone previous use and expertise was also recorded for the study. 
Results and Discussions: “The test group achieved a slightly higher average score that was not statistically significant (21.11 vs. 19.97; p = 0.302). In contrast, the performance of the individuals in the control group was significantly faster (2.41 min. vs. 4.24min; p < 0.001). Subgroup analysis showed that experienced mobile phone users performed significantly better than non experienced individuals, but not as good as participants with advanced first aid knowledge.”
\paragraph{Conclusions} ``Experience in the use of mobile phones is a precondition for the efficient use of the tested M-AID version. Furthermore, the software cannot replace skills acquisition by practical training. In a subgroup with experience in the handling of mobile phones and basic knowledge in CPR, the device improved performance of CPR.''

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/m-aid-1}
\caption{M-AID main screen}
\label{fig:m-aid-1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/m-aid-2}
\caption{Detail of the M-Aid advice}
\label{fig:m-aid-2}
\end{figure}

\section{Conclusions}
\paragraph{} Evaluation is largely the same as website/ desktop app evaluation but it has to include context. Don’t forget that the usability lab is less effective for mobile app evaluation than when you are evaluating a desktop app or a website. For mobile apps we have to move out to typical locations and situations: for example – inside, outside, in a crowd, in a park, on a bus. Think about both mobility and space. Engineer other interactions such as interruptions with phone and SMS events to see how your user can cope with your application while dealing with other typical events.

\paragraph{} Now your environment or context includes at night as well as during the day, at a rock concert, in a cathedral or in a supermarket. Never forget, however, that evaluation has to be proportionate. If you think you might sell 100 copies of your £0.79 app don’t go mad and pay users and psychologists to design a series of tests.



\section{Summary}
\paragraph{} We have looked at a range of topics related to the design and evaluation of mobile apps. You should now be able to:

\begin{itemize}
\item Use design patterns to communicate your designs
\item Use and understand platform guidelines
\item Evaluate your application
\end{itemize}

%\section{References \& Resources}




\chapter{Designing \& Engineering for Mobile}

\section{Aims}
\paragraph{} At the end of this topic you will be able to:

\begin{itemize}
\item Choose and follow a development methodology
\item Explain the mobile software development lifecycle
\item Perform Testing
\item Select the most appropriate development tools for your project
\end{itemize}


\paragraph{} We now focus on the practicalities of developing mobile apps in the wider context of software engineering and methodologies for creating effective and reliable software. Whilst in the last topic we considered the app in isolation with its own novel attributes in comparison to software on the server or desktop, instead, in this topic we consider how to engineer good apps and the methodologies we should follow if we are to build effective and reliable software. This is especially true if we consider thatin real-world development an app will rarely exist in isolation and will often be built by teams rather than individuals. An app will likely be part of a wider software system all of whose elements must work consistently together. Often an app will be developed which will work with data on the server, or services offered by 3rd parties, or will integrate closely with software on other platforms. Additionally, a team of developers working on a mobile app may have to work closely with developers building for other platforms or in different contexts. In order to make this process as smooth as possible, developers adopt software engineering methodologies and supporting tools to help them to work consistently and efficiently, to help them collaborate, and to ensure that their software artifacts are of high quality.

%SUPERHUB example.


\section{Methodologies}
\subsection{The Development Lifecycle}
\paragraph{} Developing mobile apps is simply software engineering in a specific application area. So what should our software engineering methods be?

\paragraph{} It is as if agile methods were made for mobile apps development. Short development cycles, building functionality and testing the app as you go along. The mantra is “test early, test often”. In agile, you can then stop when you have a product you can sell (or have run out of time and/ or money).

\paragraph{} Many software development projects start with a list of requirements generated from a customer/ client.  Often apps developers are drawing up their own requirements. Do a cost-benefit analysis on your project overall and of your requirements – prioritise them according to MOSCOW rules (those it must have, should have, could have and definitely won't have).

\begin{framed}
Planning to market your app? Don't forget any third-part requirements such as:
\begin{itemize}
\item Android License Agreement Requirements
\item Google Maps/ Third Party API Requirements
\item Android Market Requirements
\item Mobile Carrier/ Operator Requirements
\end{itemize}
\end{framed}

\paragraph{} A large, and underappreciated part of managing a software development project is managing risks. The biggest risk is your platform:
\begin{itemize}
\item handsets come and go at breakneck speed
\item handsets are customised for different markets \& regions
\item Android is at version 4.4 Kit-Kat– but for how long? each release is potentially significant to the success of your project
\item having access to the target handset – getting a pre-production handset might give you a competitive advantage
\end{itemize}

\paragraph{} Almost all of the most popular websites have migrated to phones – eg Facebook, BBC iPlayer – so simply expecting mobile users to browse to traditional websites is not seen as best practice for retaining your market share. Why's that?

\begin{itemize}
\item Small screen size – so need to customise
\item Limited/ uncomfortable data entry
\item Challenge of multitasking (eg Facebook is often running alongside MSN, YouTube on the desktop)
\item Representation of rich information (eg who's online, what's their strapline?)
\item Processor speed
\item Memory
\item Not always connected
\item Bandwidth
\item Expense of data roaming
\end{itemize}

\paragraph{} And from the users perspective?

\begin{itemize}
\item Interruptions likely – eg an SMS coming in
\item May be more public – more likely to be overlooked
\item May be more easily distracted
\item Need quick returns – some users download lots of apps but only use them infrequently
\end{itemize}

\subsubsection{Porting from a Desktop App} 
\paragraph{} 

\begin{itemize}
\item Avoid dialogs that pop up
\item Put interface elements under each other rather than side by side
\item To select a file – load them into a spinner
\item Test your app with one hand
\end{itemize}


\paragraph{} In summary, why are apps better than [web]sites for mobile? 
\begin{quote}
``Because the more impoverished the device, the more the design must be optimized for the platform's exact abilities, instead of bowing to a cross-platform common denominator.'' \footnote{\url{http://www.useit.com/alertbox/mobile-apps-initial-use.html}}
\end{quote}

\section{The Design Process}
\paragraph{} Jones \& Marsden (2006) define three activities involved in the design process:

\begin{itemize}
\item understanding users
\item developing prototype designs
\item evaluation – get feedback on your prototype and refine
\end{itemize}

\paragraph{} Overall, they state that interaction design should be “intensely participative and collaborative”. In most cases, to get the best results you can't go it alone – design reviews with peers and getting user feedback are useful in your app development.

\subsection{Understanding Users}
\paragraph{} To understand users you might want to conduct a field study. Ethnographers would study how people behave – taking into account collaboration, environment – observing how people behave in the situation in which the mobile app might be used. As an ethnographer you would be immersed in the environment and hopefully as invisible to the study group as possible.

\paragraph{} Do women and men behave differently? Course! Children and the elderly? The typical mobile user might not be an innovator and may not be a heavy desktop user. Your field study might observe different behaviours rather than making assumptions.

\paragraph{} Structured interviews/ direct questioning are more intrusive than ethnographic techniques, but are more direct and you can ask specific questions of your user group.

\paragraph{} How would these inform the design process? You could write up your observations \& interview results as scenarios (which are essentially use cases with more personality). This information would inform the prototyping stage as an indication of how the app could be used which in turn will inform the functionality required and the preferences in accessing/interacting with this functionality.

\subsection{Prototyping}

\paragraph{} The prototype is a basic working model of some part of an application which is either developed to get feedback into the requirements and/or design stage or which can be used as a step towards a final product. Developing a prototype is essential for mobile projects

\paragraph{} You can develop prototypes using mock up techniques (such mock-up.com, powerpoint templates, Visual Studio with Android plug-in, DroidDraw or Android App Inventor). 

\paragraph{} When developing your prototype, think about modelling the interaction with your final developed app. In particular (Jones \& Marsden,2006):
\begin{itemize}
\item direct manipulation – the iPod wheel is better than a scroll list
\item ecological use – would your context be useful eg location, other devices available to interact with eg over Bluetooth
\item design for maximum impact through minimum user effort
\item design for personalisation – people like to express their personality even though they are buying the same iPad as millions of others. Personalising makes them feel better towards their device/ app.
\item design for fun
\item design for one-handed use
\end{itemize}

\paragraph{} Add to that:

\begin{itemize}
\item design to be current OR functional (e.g. the Vuvuzela app for iPhone or the Bus Tracker – the former is use and throw away, the latter has currency through functionality)
\item use your mobile technology design guidelines\footnote{\url{http://developer.android.com/design/get-started/principles.html}} – e.g. Android offers a consistent framework for user interface components – well known ways of working with menus etc. Moving from one Android phone to another should be as easy as moving from one iPhone to another. There's no certification/ conformance rules yet but very strong guidelines on use of menus etc and icon style. They are protecting the brand.
\end{itemize}

\paragraph{} Guidelines are not just for display, guidelines are available for new gestures – the Android long press, iPhone’s pinch (now included in Android). Claiming to be intuitive, these new gestures are only intuitive if you first get shown them then all other devices use the same paradigm.
Some practical advice for apps developers:
\begin{itemize}
\item if possible, don't make users register first – hard lesson in ecommerce sites – let people put stuff in their basket before they fill out a form
\item try before you buy – or at least see before you buy
\item make it very simple – most app users are intermittent
\item include your icon design in this consideration – they might not use your app often – so make it easy for them to find when they do have the urge
\item design for performance – if you can get the work done by a server then farm it out, use efficient data structures, start fast, resume fast, use working progress tool
\item if possible, design for updates  - can extra features be plugged in without recompiling your app
\item design for interoperability  - can you work with other content providers
\item design in security – don't store or transmit non encrypted personal data
\item design for users on the go, being interrupted, having lots of apps
\end{itemize}

\subsection{Prototype Evaluation}
\paragraph{} Built your prototype? Now evaluate it – be ready to tear it up and start again – maybe you should let someone else evaluate? This is the hard bit – seeing your designs trashed. Develop a thick skin – and be a good listener. You don't always know best.

\paragraph{} Techniques include letting users loose on your prototype in a usability lab when they can be observed running through some sequence of operations. Then ask them to complete a questionnaire. You can also do some quantitative evaluation – how many keypresses are needed to run through the sequence, how long did it take etc

\paragraph{} You need enough functionality to make this prototype evaluation meaningful, however you don't want to complete your application only to find it's frustrating to use and won't sell.

\section{Development \& Testing}

\subsection{Development}
\paragraph{} Once you have established that your design is good – start developing. There’s nothing much that is particularly unique to Android app development:

\begin{itemize}
\item Pick the best IDE, i.e. Android Studio
\item Work long hours (but not silly hours)
\item FAQs and forums – if you haven’t got a google account, get one
\item Use code reviews to share good practice
\end{itemize}

\subsection{The Philosophy}

\paragraph{} The Android development philosophy includes insisting that you should keep resources external to your code where possible. Resources include strings and images. You can then look after them independently of your code. It also means that when a new device comes along with a screen shape you hadn’t anticipated you can make changes easily. Essentially: store everything in your resource directory (/res in Android Studio).


\begin{figure}[H]%[htb]
\centering
\includegraphics[width=\textwidth]{images/res_sharing}
\caption{Sharing Resources between devices}
\label{fig:res_sharing}
\end{figure}

\begin{figure}[H]%[htb]
\centering
\includegraphics[width=\textwidth]{images/res_separate}
\caption{Using alternative resources for different devices}
\label{fig:res_separate}
\end{figure}


\begin{figure}[H]%[htb]
\centering
\includegraphics[width=\textwidth]{images/res-layout-default}
\caption{Resources resized - each using the default layout}
\label{fig:res-layout-defaultt}
\end{figure}

\begin{figure}[H]%[htb]
\centering
\includegraphics[width=\textwidth]{images/res-layout-alt}
\caption{Alternative layouts for tablets}
\label{fig:res-layout-alt}
\end{figure}

\subsection{Testing}
\paragraph{} As with agile methods, test early and often. To that we can add, for mobile apps, - try to test on your target kit as early as possible. Use a range of tools – such as JUnit and Android’s Monkey Exerciser. Monkey\footnote{\url{http://developer.android.com/guide/developing/tools/monkey.html}} is a command line tool which sends a random stream of events to your application to see how it deals with them. It can be used to stress test and can run on an emulator or a device. You can configure it to set up the number of events that should be created, to identify the packages you want to test, to establish event types and their frequencies and how it should react to an error. 

\begin{framed}
Why ``monkey''? From the infinite monkey theorem – if you have enough monkeys, at enough typewriters, eventually one of them will type the complete works of Shakespeare.
\end{framed}



\section{Tooling}
\paragraph{} There are many tools that can support you in creating robust and maintainable mobile apps. If we take Android as our example, there are the pre-requisites, basically Java and the Android SDK. You can develop for Android entirely at the command-line but there are also Integrated Development Environments (IDEs) which can help you. The two main IDEs are the Android SDK based on Eclipse which was historically been the default IDE for Android development and Android Studio which because the default IDE, according to the Android project, in December 2014. It is recommended that developers new to Android should work with Android Studio unless they are already higly experienced with Eclipse. Even then, it is difficult to say for how long the Eclipse Android plugins will continue to be supported.

However, you should always be aware that whilst these tools can help and support you, they are not a substitute for knowing the platform and the problem you are trying to solve, as well as possible. One advantage that IDEs to offer however is a way to explore the Android system by exploiting the visual editor, for drawing and prototyping layouts and exploring the view options without having to remember the XML that defines each option, and by exploiting the auto-complete feature which will suggest potential methods and objects from the Android libraries and your current project.

%\subsection{Integrated Development Environments}
%\subsubsection{Android Studio}
%\paragraph{} 

%\subsubsection{Eclipse with AndroidSDK plugin}
%\paragraph{}

\subsubsection{Build Control: Gradle \& Maven}
\paragraph{} Behind the more superficial UI differences between Studio and Eclipse, are some more substantial differences. One of the most important is the build system. Studio uses Gradle whereas Eclipse uses maven. An advantage of the new approach using Gradle is that various project parameters can be set in the Gradle build file which can then be used to complete your Android Manifest. This essentially means that you can have multiple Android apps built from the same codebase and build system, each targetting different API levels or working differently according to their target platform. This increases the flexibility of what was already a flexible system for developing apps to run across a wide range of platforms. Given that Android Studio uses Gradle, and Android Studio is the `tier one' development platform for Android, we should really get to grips with Gradle.

\subsection{Version Control}
\paragraph{} Version control is fundamental whether you are working individually or as part of a team. A good version control system, such as Git, will manage all of your resources and source code, enabling you to track changes between them, to track the history of each, and to maintain multiple versions of your app. Distributed version control, with sufficient tools for reconciling different and divergent versions, is essential when working with a team of developers, enabling each to work on their own part of the codebase and providing support to reconcile any `incompatible' difference between the versions. By incompatible versions we mean where developers have made alterations to the same piece of code and a decision has to be made about which to choose over the other, or whether refactoring to include both alterations is required. 

\subsubsection{Git}
\paragraph{} Unless you are already experienced with an alternative version control system, it is recommended that you use Git. There is a very good chance that during your career you will work in a software development team that uses this tool. Whilst Android Studio supports a range of version control tools, look under the ``VCS'' menu and you will see support for CVS, Subversion, Mercurial, and Git, Studio also supports GitHub which makes it straightforward to share your code, as open source for example, but also to create an offsite backup of your project.

\subsection{Best Practises}
\paragraph{} Due to the complicated Android hardware landscape there are many potential issues and pitfalls associated with developing app, particularly if you wish to reliable target a wide range of devices. The Android documentation provides a number of best practises\footnote{\url{https://developer.android.com/guide/practices/compatibility.html}} which it is worth becoming familiar with.

\paragraph{} For example,

\begin{itemize}
\item Use density-independent measurements in your layouts, so your specifications will scale along with the screen.
\item When putting together layouts, use relative widths and heights instead of absolute values.
\item Putting in several versions of the same image file, tailored to different screen densities, can also be a good idea.
\end{itemize}

\paragraph{} Because the Android eco-system is developing so rapidly it is worth trying to stay on top of the agreed best-practises and the differences between new versions of the platform. Whilst the platform APIs are quite rigid, to all intents and practises, if a feature is not supported by a particular API level then it is not available for that target, best practises are more malleable. It is always worth retaining a critical approach with respect to best practises and asking yourself, `does this still apply?', there may be a better way but it might be that nobody has realised it yet. Therefore best-practises can evolve and improve over time as the platform develops. This can be annoying, but means that the platform is still trying to innovate and be the best that it can be, even if sometime this means there must be major changes.

\section{Summary}
\paragraph{}

\paragraph{} In this topic we covered: 
\begin{itemize}
\item Designing your apps
\item Developing and testing your apps
\end{itemize}

\section{Directed Study}
\begin{itemize}
\item Read Chapters 4-6  of Mobile Interaction Design: Matt Jones \& Gary Marsden, Wiley, 2006
\item Read Chapters 18-19 of Android Wireless Application Development: Shane Condor \& Lauren Darcey, Addison-Wesley, 2010
\item Have a look at Microsoft’s guidelines  for their “metro style\footnote{\url{http://msdn.microsoft.com/library/windowsphone/develop/fa00461b-abe1-41d1-be87-0b0fe3d3389d(v=vs.105).aspx}}” for mobile apps and highlight any that wouldn’t be applicable to Android apps and visit the developers website http://developer.android.com for tips.
\item Check your understanding of the topic by answering the following:
\begin{enumerate}
\item Have you used design guidelines before (for example, in designing a website)? Can those be applied here?
\item What do interaction designers mean by “ethnography”?
\item If you are designing an app for older people, how would you contact a user group?
\item Why do you think SMS worked – beyond anyone's expectations?
\item Name 5 design rules built in to Android. Start by reading the Android design guidelines\footnote{\url{http://developer.android.com/guide/practices/ui_guidelines/index.html}}
\end{enumerate}
\item If you have time, build up an archive of your design ideas and inspiration from elsewhere – screen shots of killer apps, colour palettes, screen shots of your own work – critique your collection.
\end{itemize}


%\section{References \& Resources}




%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CASE STUDIES 
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%


\begin{comment}
\part{Case Studies}
\chapter{Daybook}
\label{daybook}
\paragraph{}
\end{comment}

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% APPENDICES 
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\begin{comment}
\appendix
\chapter{}
\label{}
\paragraph{} 
\end{comment}







\backmatter

\bibliographystyle{plain}

\bibliography{mobile-apps}

\end{document}

